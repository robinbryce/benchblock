interpreter: bash -c
name: bbake
usage: |

  Use the `new' command to create a full configuration for a supported
  consensus scheme. A number of pre-configured profiles are available and are
  selected as the default basis depending on the consensus chosen. For example

    `bbake new . raft`

  Will create a raft network configuration using the default profile for a raft
  docker-compose based network (configs/raft-compose-default.json). And

    `bbake new --k8s --maxnodes 9 . raft`

  Will select configs/raft-k8s-9.json - which configures a raft network with 9
  nodes and generates a deployable (kustomize based) set of kubernetes
  manifiests.

  The values configured by the profile can be overriden individualy by
  corresponding command line options.

  `new -i' will perform the configuration without generatng keys or other
  genesis materials.

  `raft`, `ibft` and `rrr`, respectively, will generate (or regenerate) the
  genesis materials and any related network configuration necessary in order to
  start a chain. The appropriate command from this set is invoked automatically
  by `new` unless -i is set.

  `gethkeys' and `gethgendoc' are used to generate the node keys and genesis
  document for all consensus models (and to force re-genesis). commands
  prefixed with `raft', `rrr', or `ibft' deal with coresponding consensus
  schemes.

  The various sub commands can be useful if you want to regenerate keys, reset
  a chain or perform other maintenance on a configuration without reseting it
  completely. Review the definition of the main conesnsus commands `raft',
  `ibft' and 'rrr' to see the individual commands that effect each.

  `jpcfg' readies a network configuration for collecting chainhammer compatible
  block data and `jpyrender' processes the data collected by the load
  generation tool [see ](./go/bbeth/main.go)

  The other commands provide various conveniences

options:

  blockperiod:
    usage: >
      ibft - sets the interval between blocks

  composeproject:
    usage: alternate docker compose project name
    default: ""

  gaslimit:
    usage: sets the --miner.gaslimit option for the nodes
    # default: "18200000"
  gastarget:
    usage: sets the --miner.gastarget option for the nodes
    # default: "18200000"
  gendoc_balance:
    default: "1000000000000000000000000000"
  gendoc_wallet:
    usage: >
      This wallet address will be included in the gensis document allocs.
      Its balance is set by gendoc_balance. This is a convenience that
      enables the same wallet key to be re-used accross multiple
      configurations.
    default: ""
  genesis:
    default: genesis-in.json
    short: "g"
  geth_image:
    usage: geth client the docker iamge
    default: ""

  etherbase:
    default: ""
  k8s:
    usage: >
      Generate a set of kubernetes manifiests (kustomizations) instead of
      the default docker-compose setup.
    type: bool
    short: k
  maxnodes:
    usage: >
      The number of nodes for the network. For PoA networks, it is the number
      of *validating* nodes.
    default: ""
    short: "n"
  name:
    usage: >
      The network name, defaults to <consensus><maxnodes>
    default: ""
  netrestrict:
    default: ""
  networkid:
    default: ""
  nodesdir:
    usage: >
      each node gets a subdirectory here named node{N}. relative paths are
      relative to the callers cwd.  defaults to <consensus>/nodes
    default: ""
  nodeallocs:
    usage: >
      How many of the node keys to create alloc accounts for. The ballance
      is set to gendoc_balance for all.
    default: 0
  pyenv:
    usage: >
      Override the directory to create the python virtualenv in. By default
      there is an env per network. This option can be used to share the env.
      By default it will be called env and created in the configdir
    default: ""
  # source options. only used for compose networks and then only if
  # interactively debuging the node
  quorum_src:
    usage: >
      the host directory to be mounted as /go/src/quorum. must contain quorum
      clone.  only required if you need to interactively debug the node.
    default:
      command: echo ""
  recommit:
    usage: >
      sets the --miner.recommit option for the nodes. currently set high
      because it invalidates the current round intent if it fires mid round
    default: ""

  raftblocktime:
    usage: >
      raft - time between blocks

  # rrr options
  rrr_image:
    usage: rrr - docker image of a geth client with rrr support
    default: ""
  rrrctl_image:
    usage: rrr - docker image for rrrctl (needed to produce rrr extraData)
    default: ""
  rrr_src:
    default:
      command: echo ""
  activehorizon:
    usage: >
      rrr - identities that don't record activity in this number of rounds are
      culled (Ta from the paper)
    default: ""
  activemethod:
    usage: >
      rrr - chose how the active selection is managed (this is a rrr developer
      option)
    default: ""

  committeequorum:
    usage: >
      rrr - required number of endorsements in a round required to mine a block
    default: ""
  confirmphase:
    usage: >
      rrr - number of milli seconds to allow wait for endorsements for the
      intents
  intentphase:
    usage: >
      rrr - number of milli seconds to allow for leader candidate intents to
      arrive
    default: ""
  numcandidates:
    usage: >
      rrr - number of leader candidates in a round. must be the same for all
      nodes. NOTICE: this option will be moved to genesis config eventually
    default: ""
  numendorsers:
    usage: >
      rrr - number of endorsers in a round. must be the same for all nodes.
      NOTICE: this option will be moved to genesis config eventually
    default: ""
  roundlength:
    usage: >
      rrr - number of milli seconds for the total round. intentphase +
      confirmphase must be less than this and the *remainder* is time to allow
      for the new block to be diseminated around the network
    default: ""

  # treat the following as private even if they are not
  launchdir:
    # treat this as private
    usage: >
      Don't set this option. Its a work around for a go-tusk peculiarity
    environment: PWD

  config:
    private: true
    usage: >
      Base filename of the config file to use in configdir. Enables alternate
      configs for the same network.
    default:
      bench.json
  configshow:
    usage: "Report which, if any, supported configdir config file VAR's"
    type: bool
  # private vars
  thistusk:
    private: true
    usage: "so this tusk file can refer to its own file name for recursive execution"
    default:
      command: echo $(pwd)/tusk.yml

  ibftvars:
    private: true
    usage: >
      Config vars exclusive to ibft
    default: >-
      blockperiod
      requesttimeout

  raftvars:
    private: true
    usage: >
      Config vars exclusive to raft
    default: >-
      raftblocktime

  rrrvars:
    private: true
    usage: >
      Config vars exclusive to rrr
    default: >-
      activemethod
      activehorizon
      committeequorum
      confirmphase
      intentphase
      numcandidates
      numendorsers
      roundlength
      rrr_image
      rrr_src
      rrrctl_image

  configvars:
    private: true
    usage: >
      All supported configuration variabes. All can be set by `new` when
      creating the configuration. Consensus specific sub commands can be used
      to update them later.
    default: >-
      bootnode0
      consensus
      composeproject
      delve_image
      gaslimit
      gastarget
      gendoc_balance
      gendoc_extra
      gendoc_wallet
      genesis
      geth_image
      etherbase
      k8s
      maxnodes
      name
      networkid
      netrestrict
      etherbase
      nodesdir
      nodeallocs
      numbootnodes
      pyenv
      quorum_src
      recommit
      ${ibftvars}
      ${raftvars}
      ${rrrvars}

tasks:

  loadtest:
    include: tuskfiles/loadtool.yml

  new:
    usage: >
      Configure a new network configdir from a stock profile
    options:
      profile:
        short: "p"
        usage: provide the default configuration values
      init-only:
        type: bool
        short: "i"
      context:
        usage: "kubernetes (kubectl) config context to use. Ignored unless the profile enables k8s manifiests"
        short: "c"
        default: ""

    args:
      configdir:
      consensus:
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e
            TUSKDIR=$(pwd)

            echo "launchdir: ${launchdir}"

            # Any options set on the command line are transalted here to
            # BBENCH_ env vars. This has the effect that cli options have
            # highest priority and will always make it to the bench.json config
            # BBAKE_ env vars, if set (and possibly empty), will only make it
            # through if the correspoding cli option is not set. Note that this
            # section is the single source of truth for the supported cli
            # configuration options. Other config values may be permited using
            # profiles but, if they are not listed here, they can only be set
            # in the profile. The configvars task lists the full set of
            # variables that are significant in banch.json (any other entries
            # are ignored)
            #
            # [ -n "${K8S}" ] && BBAKE_K8S=
            BBAKE_CONSENSUS=${consensus}

            [ -n "${composeproject}" ] && export BBAKE_COMPOSEPROJECT=${composeproject}
            [ -n "${etherbase}" ] && export BBAKE_ETHERBASE=${etherbase}
            [ -n "${gaslimit}" ] && export BBAKE_GASLIMIT=${gaslimit}
            [ -n "${gastarget}" ] && export BBAKE_GASTARGET=${gastarget}
            [ -n "${gendoc_ballance}" ] && export BBAKE_GENDOC_BALANCE=${gendoc_ballance}
            [ -n "${gensis}" ] && export BBAKE_GENESIS=${genesis}
            [ -n "${geth_image}" ] && export BBAKE_GETH_IMAGE=${geth_image}
            [ -n "${maxnodes}" ] && export BBAKE_MAXNODES=${maxnodes}
            [ -n "${name}" ] && export BBAKE_NAME=${name}
            [ -n "${networkid}" ] && export BBAKE_NETWORKID=${networkid}
            [ -n "${netrestrict}" ] && export BBAKE_NETRESTRICT=${netrestrict}
            [ -n "${nodeallocs}" ] && export BBAKE_NODEALLOCS=${nodeallocs}
            # [ -n "${nodesdir}" ] && export BBAKE_NODESDIR=${nodesdir} handled in the
            # PYEND block below
            [ -n "${numbootnodes}" ] && export BBAKE_NUMBOOTNODES=${numbootnodes}
            [ -n "${pyenv}" ] && export BBAKE_PYENV=${pyenv}
            [ -n "${quorum_src}" ] && export BBAKE_QUORUM_SRC=${quorum_src}
            [ -n "${recommit}" ] && export BBAKE_RECOMMIT=${recommit}
            # ibft
            [ -n "${blockperiod}" ] && export BBAKE_BLOCKPERIOD=${blockperiod}
            # raft
            [ -n "${raftblocktime}" ] && export BBAKE_RAFTBLOCKTIME=${raftblocktime}
            # rrr
            [ -n "${activemethod}" ] && export BBAKE_ACTIVEMETHOD=${activemethod}
            [ -n "${activehorizon}" ] && export BBAKE_ACTIVEHORIZON=${activehorizon}
            [ -n "${committeequorum}" ] && export BBAKE_COMMITTEEQUORUM=${committeequorum}
            [ -n "${intentphase}" ] && export BBAKE_INTENTPHASE=${intentphase}
            [ -n "${confirmphase}" ] && export BBAKE_CONFIRMPHASE=${confirmphase}
            [ -n "${numcandidates}" ] && export BBAKE_NUMCANDIDATES=${numcandidates}
            [ -n "${numendorsers}" ] && export BBAKE_NUMENDORSERS=${numendorsers}
            [ -n "${roundlength}" ] && export BBAKE_ROUNDLENGTH=${roundlength}
            [ -n "${rrr_image}" ] && export BBAKE_RRR_IMAGE=${rrr_image}
            [ -n "${rrr_src}" ] && export BBAKE_RRR_SRC=${rrr_src}
            [ -n "${rrrctl_image}" ] && export BBAKE_RRRCTL_IMAGE=${rrr_image}

            cat <<PYEND | python3
            import os, sys, json
            from pathlib import Path

            tuskdir = Path(os.getcwd()).resolve()

            configdir = "${configdir}"
            configdir = Path("${launchdir}").joinpath(configdir).resolve()
            configdir.mkdir(parents=True, exist_ok=True)
            os.chdir(configdir)

            def env(name, default=""):
              # Note that when env vars are set explicitly empty this will
              # trump the default argument here
              return os.environ.get(f"BBAKE_{name.upper()}", default)

            # if the user supplies a path, resolve it against the launchdir
            # rather than the config dir (so that the result is consistent with
            # cli tab completion)
            if "${nodesdir}":
              nodesdir = Path("${launchdir}").joinpath("${nodesdir}").resolve()
            else:
              # nodesdir defaults to configdir/<consensus>/nodes
              nodesdir = configdir.joinpath("${consensus}", "nodes").resolve()

            nodesdir.mkdir(parents=True, exist_ok=True)

            # The configuration defaults come from the appropriate benchblock
            # profile for the consensus and deployment method
            deploymode="k8s"
            if "${k8s}" != "true":
              deploymode="compose"

            bench_json = {}

            consensus="${consensus}"

            # process default profiles
            for profile in [
                f"default",
                f"{deploymode}-default",
                f"{consensus}-default",
                f"{consensus}-{deploymode}-default"
                ]:
              defaults = tuskdir.joinpath("configs", f"{profile}.json").resolve()
              if defaults.exists():
                bench_json.update(json.load(open(defaults)))

            profile = "${profile}"
            if profile:
              # try first as whole file relative to launch dir
              for p in [
                Path("${launchdir}").joinpath(profile).resolve(),
                Path(profile)]:
                if not p.is_file():
                  continue
                bench_json.update(json.load(open(profile)))
                print(f"using profile: {profile}")
                break
              else:
                print(f"profile {profile} does not exist")

            # If its in the profile, normalise against configdir
            if "pyenv" in bench_json:
              bench_json["pyenv"] = str(configdir.joinpath(bench_json["pyenv"]))
            else:
              # otherwise, normalise from options or env against launchdir
              # pyenvdir defaults to configdir/env
              pyenvdir = env("PYENV", "env")
              pyenvdir = Path("${launchdir}").joinpath(pyenvdir).resolve()
              bench_json['pyenv'] = str(pyenvdir)

            # now prioritize any explicit options to new over what is present in
            # the profile

            for k in "${configvars}".split():

              if k == "consensus":
                # This is a command argument, not an option
                continue

              v = env(k, default=None)
              # v will only be None if the env var is not set. If the cli
              # option was set not empty then the env var will be set. This
              # allows env to be used to force a config value to the empty
              # string.
              if v is None:
                continue

              # if there is nothing in the profile (or we don't have one) fall
              # back to the env var (which may have been set from CLI)
              if not bench_json.get(k):
                bench_json[k] = v
                print(f"{k}: {bench_json[k]} (bbake new default)")
                continue

              # If we got a value from the cli or the env, it takes precedence
              # over anything we got from the profile
              bench_json[k] = v
              print(f"{k}: {v} (set by option, env or profile)")

            bench_json["consensus"] = "${consensus}"
            bench_json["nodesdir"] = str(nodesdir)

            # deal with any constructed defaults.
            if not bench_json.get("name"):
              bench_json["name"] = consensus + str(bench_json["maxnodes"])

            with open("bench.json", "w") as f:
                json.dump(bench_json, f, indent=2, sort_keys=True)

            print(json.dumps(bench_json, indent=2, sort_keys=True))
            print(f"Wrote: {os.getcwd()}/bench.json")
            PYEND

            eval ${READ_CONFIG}

            python3 -m venv ${BBAKE_PYENV}
            source ${BBAKE_PYENV}/bin/activate
            pip3 install -r ${TUSKDIR}/requirements.txt

            cd ${launchdir} && cd ${configdir}

            [ -d ${TUSKDIR}/k8s/${BBAKE_CONSENSUS} ] && mkdir -p ${BBAKE_CONSENSUS}

            if ${k8s}; then
              [ -d ${TUSKDIR}/k8s/base ] && mkdir -p base && cp -r ${TUSKDIR}/k8s/base/* base
              [ -d ${TUSKDIR}/k8s/jobs ] && mkdir -p jobs && cp -r ${TUSKDIR}/k8s/jobs/* jobs
              [ -d ${TUSKDIR}/k8s/${BBAKE_CONSENSUS} ] && cp -r ${TUSKDIR}/k8s/${BBAKE_CONSENSUS}/* ${BBAKE_CONSENSUS}
            fi
            cat bench.json

      - when:
          equal: {init-only: false}
        command:
          exec: |
            set -e
            TUSKDIR=$(pwd)
            cd ${launchdir}
            tusk -qf ${TUSKDIR}/tusk.yml ${consensus} ${configdir}

  ibft:
    usage: >
      Configure, or reconfigure, an ibft network

    args:
      configdir:
        usage: Directory to put the network in
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e
            TUSKDIR=$(pwd)

            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; fi

            [ "${BBAKE_CONSENSUS}" != "ibft" ] && echo "Configured for ${BBAKE_CONSENSUS} not ibft" && exit 1

            # prioritize any options over environment and profile.
            [ -n "${gaslimit}" ] && export BBAKE_GASLIMIT=${gaslimit}
            [ -n "${gastarget}" ] && export BBAKE_GASTARGET=${gastarget}
            [ -n "${gendoc_ballance}" ] && export BBAKE_GENDOC_BALANCE=${gendoc_ballance}
            [ -n "${gensis}" ] && export BBAKE_GENESIS=${genesis}
            [ -n "${geth_image}" ] && export BBAKE_GETH_IMAGE=${geth_image}
            [ -n "${maxnodes}" ] && export BBAKE_MAXNODES=${maxnodes}
            # export BBAKE_NAME=
            [ -n "${networkid}" ] && export BBAKE_NETWORKID=${networkid}
            [ -n "${nodeallocs}" ] && export BBAKE_NODEALLOCS=${nodeallocs}
            # export BBAKE_NODESDIR=
            [ -n "${numbootnodes}" ] && export BBAKE_NUMBOOTNODES=${numbootnodes}
            # export BBAKE_PYENV=
            [ -n "${quorum_src}" ] && export BBAKE_QUORUM_SRC=${quorum_src}
            [ -n "${recommit}" ] && export BBAKE_RECOMMIT=${recommit}

            [ -n "${blockperiod}" ] && export BBAKE_BLOCKPERIOD=${BBAKE_BLOCKPERIOD}
            [ -n "${requesttimeout}" ] && export BBAKE_REQUESTTIMEOUT=${requesttimeout}

            cd ${launchdir} && cd ${configdir}

            eval ${UPDATE_CONFIG}

      - task:
          name: gethkeys
          args:
            - ${configdir}
      - task:
          name: ibftextra
          args:
            - ${configdir}
      - task:
          name: gethstatic
          args:
            - ${configdir}
      - task:
          name: gethgen
          args:
            - ${configdir}

      - command:
          exec: |
            set -e
            TUSKDIR=$(pwd)
            CONFIGVARS="${configvars}"
            eval ${READ_CONFIG}

            CMD=ibftcompose
            ${BBAKE_K8S} && CMD=ibftk8s

            cd ${launchdir}
            tusk -qf ${TUSKDIR}/tusk.yml ${CMD} ${configdir}

  raft:
    usage: >
      Configure, or reconfigure, a raft network
    args:
      configdir:
        usage: Directory to put the network in
    run:
      - task:
          name: configure
          args:
            - ${configdir}

      - command:
          exec: |
            set -e
            TUSKDIR=$(pwd)

            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; fi

            [ "${BBAKE_CONSENSUS}" != "raft" ] && echo "Configured for ${BBAKE_CONSENSUS} not raft" && exit 1

            # prioritize any options over environment and profile.
            [ -n "${gaslimit}" ] && export BBAKE_GASLIMIT=${gaslimit}
            [ -n "${gastarget}" ] && export BBAKE_GASTARGET=${gastarget}
            [ -n "${gendoc_ballance}" ] && export BBAKE_GENDOC_BALANCE=${gendoc_ballance}
            [ -n "${gensis}" ] && export BBAKE_GENESIS=${genesis}
            [ -n "${geth_image}" ] && export BBAKE_GETH_IMAGE=${geth_image}
            [ -n "${maxnodes}" ] && export BBAKE_MAXNODES=${maxnodes}
            # export BBAKE_NAME=
            [ -n "${networkid}" ] && export BBAKE_NETWORKID=${networkid}
            [ -n "${nodeallocs}" ] && export BBAKE_NODEALLOCS=${nodeallocs}
            # export BBAKE_NODESDIR=
            [ -n "${numbootnodes}" ] && export BBAKE_NUMBOOTNODES=${numbootnodes}
            # export BBAKE_PYENV=
            [ -n "${quorum_src}" ] && export BBAKE_QUORUM_SRC=${quorum_src}
            [ -n "${recommit}" ] && export BBAKE_RECOMMIT=${recommit}

            [ -n "${raftblocktime}" ] && export BBAKE_RAFTBLOCKTIME=${raftblocktime}

            # prioritize commandline setting for raft blocktime. if its not
            # already set (by the profile or by hand) force it to 50 (the
            # quorum default)
            [ -z "${RAFT_RAFTBLOCKTIME}" ] && RAFT_RAFTBLOCKTIME=50

            cd ${launchdir} && cd ${configdir}
            eval ${UPDATE_CONFIG}
            cat bench.json

      - task:
          name: gethkeys
          args:
            - ${configdir}
      - task:
          name: gethstatic
          options:
            querystring: "?discport=0&raftport=50000"
          args:
            - ${configdir}
      - task:
         name: gethgen
         args:
           - ${configdir}
      - command:
          exec: |
            set -e
            TUSKDIR=$(pwd)
            CONFIGVARS="${configvars}"
            eval ${READ_CONFIG}

            CMD=raftcompose
            ${BBAKE_K8S} && CMD=raftk8s

            cd ${launchdir}
            tusk -qf ${TUSKDIR}/tusk.yml ${CMD} ${configdir}

  rrr:
    usage: >
      Configure, or re-configure, an rrr network
      # This task also ilustrates the full sequence of steps to prepare an rrr
      # compose setup
    args:
      configdir:
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)

            # read the config file fields into BBAKE_ vars.
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; fi

            [ "${BBAKE_CONSENSUS}" != "rrr" ] && echo "Configured for ${BBAKE_CONSENSUS} not rrr" && exit 1

            # prioritize any options over environment and profile.
            [ -n "${gaslimit}" ] && export BBAKE_GASLIMIT=${gaslimit}
            [ -n "${gastarget}" ] && export BBAKE_GASTARGET=${gastarget}
            [ -n "${gendoc_ballance}" ] && export BBAKE_GENDOC_BALANCE=${gendoc_ballance}
            [ -n "${gensis}" ] && export BBAKE_GENESIS=${genesis}
            [ -n "${geth_image}" ] && export BBAKE_GETH_IMAGE=${geth_image}
            [ -n "${maxnodes}" ] && export BBAKE_MAXNODES=${maxnodes}
            # export BBAKE_NAME=
            [ -n "${networkid}" ] && export BBAKE_NETWORKID=${networkid}
            [ -n "${nodeallocs}" ] && export BBAKE_NODEALLOCS=${nodeallocs}
            # export BBAKE_NODESDIR=
            [ -n "${numbootnodes}" ] && export BBAKE_NUMBOOTNODES=${numbootnodes}
            # export BBAKE_PYENV=
            [ -n "${quorum_src}" ] && export BBAKE_QUORUM_SRC=${quorum_src}
            [ -n "${recommit}" ] && export BBAKE_RECOMMIT=${recommit}
            [ -n "${rrr_image}" ] && export BBAKE_RRR_IMAGE=${rrr_image}
            [ -n "${rrr_src}" ] && export BBAKE_RRR_SRC=${rrr_src}
            [ -n "${rrrctl_image}" ] && export BBAKE_RRRCTL_IMAGE=${rrr_image}

            cd ${launchdir} && cd ${configdir}

            eval ${UPDATE_CONFIG}
            cat bench.json

      - task:
          name: gethkeys
          args:
            - ${configdir}
      - task:
          # this is just to provide config for the loadtool. its ignored
          # otherwise
          name: gethstatic
          args:
            - ${configdir}
      - task:
          name: rrralpha
          args:
            - ${configdir}

      - task:
          name: rrrinit
          args:
            - ${configdir}
      - command:
          exec: |
            set -e
            TUSKDIR=$(pwd)
            eval ${READ_CONFIG}

            CMD=rrrcompose
            ${BBAKE_K8S} && CMD=rrrk8s

            cd ${launchdir}
            tusk -qf ${TUSKDIR}/tusk.yml ${CMD} ${configdir}

  configure:
    usage: >
      Put the rune for reading the config file into an environment variable so
      that it can be more readily re-used.  This one horror pays for a lot of
      simplicity elsewhere. The double cd trick combines the launchdir captured
      before tusk changes directory to the task file and then combines it with
      the cli choice of current directory. So that the cli choice remains
      relative to the launchdir.  Then we suck out the top level fields in the
      json config directory and expose them in a bash friendly format. This
      enables both shell tusk tasks and python to share the same config,
      without having to duplicate a bunch of stuff.
    private: true
    args:
      configdir:
    run:
      # execute these fragments in the task like this:
      #   eval ${READ_CONFIG}
      #   if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
      set-environment:
        READ_CONFIG: "\
          $(cd ${launchdir} && cd ${configdir} \
          && python3 -c \"import json; import shlex;\
                          [print(f'export BBAKE_{k.upper()}={v}') \
                              for k, v in json.load(open('${config}')).items() if v]\")"
        SHOW_CONFIG: "for v in ${configvars}; do vv=BBAKE_${v^^}; echo ${vv}=${!vv}; done"

        UPDATE_CONFIG: |
          python3 -c "import os, json, pathlib;
          config=\"${config}\";
          configvars=\"${configvars}\";
          j = json.load(open(config, \"r\"));
          #print(json.dumps(j, indent=2, sort_keys=True));
          vars = configvars.split();
          u = dict([(k, os.environ.get(f\"BBAKE_{k.upper()}\", j[k])) for k in vars if k in j]);
          outname=pathlib.Path(config).resolve();
          outs = json.dumps(u, indent=2, sort_keys=True);
          f = open(outname, \"w\");
          f.write(outs);
          f.flush();
          print(outs);
          print(f\"Wrote: {outname}\")";


  gethgendoc:
    include: tuskfiles/gethgendoc.yml

  gethkeys:
    include: tuskfiles/gethkeys.yml

  gethgen:
    include: tuskfiles/gethgen.yml

  gethstatic:
    include: tuskfiles/gethstatic.yml

  # raft consensus commands
  raftk8s:
    include: tuskfiles/raftk8s.yml

  # ibft consensus commands
  ibftextra:
    include: tuskfiles/ibftextra.yml

  ibftcompose:
    include: tuskfiles/ibftcompose.yml

  ibftk8s:
    include: tuskfiles/ibftk8s.yml

  # raft consensus commands
  raftcompose:
    include: tuskfiles/raftcompose.yml

  # rrr consensus commands
  rrralpha:
    include: tuskfiles/rrralpha.yml

  rrrextra:
    include: tuskfiles/rrrextra.yml

  rrrinit:
    include: tuskfiles/rrrinit.yml

  rrrcompose:
    include: tuskfiles/rrrcompose.yml

  rrrk8s:
    include: tuskfiles/rrrk8s.yml

  knet:
    include: tuskfiles/knet.yml

  kex:
    usage: >
      execute a command in the nodes js console via kubectl exec
    options:
      node:
        short: "i"
        default: 0
        type: int
    args:
      configdir:
      exec:
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e
            # read the config file fields into BBAKE_ vars.
            eval ${READ_CONFIG}

            cd ${launchdir} && cd ${configdir}

            i=${node}
            POD=${BBAKE_NAME}-ethnode${i}-0
            export POD

            kubectl \
              $([ -z '${exec}' ] && echo -n '-it') \
              -n ${BBAKE_NAME} exec ${POD} -- \
              /usr/local/bin/geth \
              attach /data/node/geth.ipc \
                $([ -n '${exec}' ] && echo -n --exec '${exec}')


  # jupyter reporting
  jpycfg:
    include: tuskfiles/jpycfg.yml

  jpyrender:
    include: tuskfiles/jpyrender.yml

  tonb:
    usage: "convert the markdown notebook to ipython notebook format"
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)
            eval ${READ_CONFIG}
            cd ${launchdir} && cd ${configdir}

            source ${pyenv}/bin/activate
            cat standard-plots.md | jupytext --from .md --to notebook --output standard-plots.ipynb

  tomd:
    usage: "convert the ipython notebook format back to markdown"
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)
            eval ${READ_CONFIG}
            cd ${launchdir} && cd ${configdir}

            source ${pyenv}/bin/activate
            cat standard-plots.md | jupytext --from .md --to notebook --output standard-plots.ipynb

