usage: |
  Generate the network wide kustomizations for rrr

options:
  # don't set default values here, put them in set-environment below
  networkid:
    default: ""
  numbootnodes:
    short: b
  gastarget:
    usage: "sets the --miner.gastarget option for the nodes"
  gaslimit:
    usage: "sets the --miner.gaslimit option for the nodes"
  recommit:
    usage: "sets the --miner.recommit option for the nodes."

args:
  configdir:
    usage: >
      The config root directory.

run:
  - task:
      name: configure
      args:
        - ${configdir}
  - command:
      exec: |
        set -e
        TUSKDIR=$(pwd)

        # read the config file fields into BBAKE_ vars.
        eval ${READ_CONFIG}

        cd ${launchdir} && cd ${configdir}
        [ -n "${etherbase}" ] && BBAKE_ETHERBASE=${etherbase}
        [ -n "${gaslimit}" ] && BBAKE_GASLIMIT=${gaslimit}
        [ -n "${gastarget}" ] && BBAKE_GASTARGET=${gastarget}
        [ -n "${numbootnodes}" ] && BBAKE_NUMBOOTNODES=${numbootnodes}
        [ -n "${netrestrict}" ] && BBAKE_NETRESTRICT=${netrestrict}
        [ -n "${networkid}" ] && BBAKE_NETWORKID=${networkid}
        [ -n "${recommit}" ] && BBAKE_RECOMMIT=${recommit}

        [ -z ${BBAKE_COMPOSEPROJECT} ] && BBAKE_COMPOSEPROJECT=${BBAKE_NAME}
        [ -z "$BBAKE_ETHERBASE" ] && export BBAKE_ETHERBASE=${BBAKE_GENDOC_WALLET}

        # For a development & experimental setup its not clear it really
        # matters what address we use for ETHERBASE. But using node0 seems like
        # a default that could be convenient.
        source ${BBAKE_PYENV}/bin/activate
        BBAKE_ETHERBASE=$(cat <<PYEND | python3
        import os, sys, pathlib, coincurve, sha3
        if os.environ["BBAKE_ETHERBASE"] or os.environ["BBAKE_ETHERBASE"] == "0x0000000000000000000000000000000000000000":
            sys.exit(0)
        with open(pathlib.Path(os.environ["BBAKE_NODESDIR"]).joinpath("node0", "key")) as f:
            key = coincurve.PrivateKey.from_hex(f.read())
            pub = key.public_key.format(compressed=False)[1:]
            print("0x" + sha3.keccak_256(pub).digest()[-20:].hex())
        PYEND
        )

        export GAS_OPTS="${BBAKE_RECOMMIT:+ --miner.recommit "${BBAKE_RECOMMIT}"} --miner.gastarget ${BBAKE_GASTARGET} --miner.gaslimit ${BBAKE_GASLIMIT}"
        export CONSENSUS_OPTS="\
        ${BBAKE_ACTIVEMETHOD:+ --rrr.method $BBAKE_ACTIVEMETHOD} \
        --rrr.nc ${BBAKE_NUMCANDIDATES} \
        --rrr.ne ${BBAKE_NUMENDORSERS} \
        --rrr.q ${BBAKE_COMMITTEEQUORUM} \
        --rrr.ta ${BBAKE_ACTIVEHORIZON} \
        --rrr.intentphase ${BBAKE_INTENTPHASE} \
        --rrr.confirmphase ${BBAKE_CONFIRMPHASE} \
        --rrr.roundlength ${BBAKE_ROUNDLENGTH}"

        eval ${UPDATE_CONFIG}
        # configuration inputs finalised. everything from here is derived.

        mkdir -p rrr/network

        cat <<END > rrr/network/network.env
        CONSENSUS_OPTS=${CONSENSUS_OPTS}
        NETWORKID=${BBAKE_NETWORKID}
        ETHERBASE=${BBAKE_ETHERBASE}
        GETH_IMAGE=${BBAKE_GETH_IMAGE}
        GAS_OPTS=$GAS_OPTS
        LOG_OPTS=--vmodule consensus/*=5,miner/*=2,eth/*=2,p2p/discover/*=2 --verbosity 2
        END
        cat rrr/network/network.env
        echo "Wrote rrr/network/network.env"

        rm -f rrr/network/bootnodes.env
        for i in $(seq 0 $((${BBAKE_NUMBOOTNODES} - 1))); do
          echo "BOOTNODE_PUB${i}=$(cat ${BBAKE_NODESDIR}/node${i}/enode)" >> rrr/network/bootnodes.env
          echo "BOOTNODE_HOST${i}=ethnode${i}-0.ethnode${i}.${BBAKE_NAME}.svc.cluster.local" >> rrr/network/bootnodes.env
        done
        cat rrr/network/bootnodes.env
        echo "Wrote ${BBAKE_NUMBOOTNODES} bootnodes to rrr/network/bootnodes.env"

        cp ${BBAKE_NODESDIR}/genesis.json rrr/network

        # rrr uses discovery. we generate static-nodes.json anyway to be
        # consistent.
        cp ${BBAKE_NODESDIR}/static-nodes.json rrr/network

        # this assumes static-nodes.json is generated for compose with the hosts listed in
        # ascending order node0, node1 ...
        # > ethnode8.{BBAKE_NAME}.svc.cluster.local
        cat <<PYEND | python3
        import os, json
        from urllib.parse import urlparse, urlunparse
        nodes = []
        nodesdir = os.environ['BBAKE_NODESDIR']
        namespace = os.environ['BBAKE_NAME']
        consensus = os.environ['BBAKE_CONSENSUS']
        for i, u in enumerate(json.load(open(f"{nodesdir}/static-nodes.json"))):
          u = urlparse(u)
          if u.hostname != f"node{i}":
            print(f"ERROR: static nodes declared in unexpected order or just plain wrong")
            sys.exit(1)

          nodename = f"ethnode{i}"
          u = urlunparse((u.scheme, f"{u.username}@{nodename}-0.{nodename}.{namespace}.svc.cluster.local:{u.port}", '', '', u.query, ''))
          nodes.append(u)
        json.dump(nodes, open(f"{consensus}/network/static-nodes.json", "w"), sort_keys=True, indent=True)
        PYEND

        # kustomizations for jobs
        cp -v rrr/network/static-nodes.json jobs/loadtest
        cat base/jobs/loadtest/bbeth.json | jq -r \
          '.bbeth.load.transactions = 10000 |
           .bbeth.load.nodes = (env.BBAKE_MAXNODES|tonumber) |
           .bbeth.load.threads = (env.BBAKE_MAXNODES|tonumber)' \
           > jobs/loadtest/bbeth.json
        echo "Wrote jobs/loadtest/bbeth.json"
        yq eval ".namespace = \"$BBAKE_NAME\"" \
          ${TUSKDIR}/k8s/jobs/loadtest/kustomization.yaml | \
          tee jobs/loadtest/kustomization.yaml
        echo "Wrote rrr/kustomization.yaml"

        # patch kustomizations for the rrr base node. once applied consumer is
        # expected to leave alone
        for i in $(seq 0 $((${BBAKE_NUMBOOTNODES} - 1))); do
          NODENUM=$i yq eval \
            '.spec.template.spec.containers[].env[].name += env(NODENUM) |
             .spec.template.spec.containers[].env[].valueFrom.configMapKeyRef.key += env(NODENUM)
            ' \
            ${TUSKDIR}/k8s/base/rrr/node/statefulset-env-bootnode.yaml \
            > base/rrr/node/statefulset-env-bootnode${i}.yaml
          cat base/rrr/node/statefulset-env-bootnode${i}.yaml
          echo "Wrote: base/rrr/node/statefulset-env-bootnode${i}.yaml"
          echo "- statefulset-env-bootnode${i}.yaml" >> base/rrr/node/kustomization-patches.yaml
        done
        if [ ${BBAKE_NUMBOOTNODES} -gt 0 ]; then
          yq eval-all --inplace 'select(fi==0) *+ {"patchesStrategicMerge": select(fi==1)}' \
            base/rrr/node/kustomization.yaml base/rrr/node/kustomization-patches.yaml
          cat base/rrr/node/kustomization.yaml
          echo "Updated: base/rrr/node/kustomization.yaml"
          rm -f base/rrr/node/kustomization-patches.yaml
        fi

        # patch the kustomizations for the base boot nodes. once patched
        # consumer is expected to leave alone
        # * suffix app and k8s/name labels with the node index
        # * refer to the bootnode base
        for i in $(seq 0 $((${BBAKE_NUMBOOTNODES} - 1))); do
          NODENUM=$i yq eval '.nameSuffix = env(NODENUM) |
          .commonLabels.app += env(NODENUM) |
          .commonLabels.bootnode = strenv(NODENUM) |
          .commonLabels."app.kubernetes.io/name" += env(NODENUM) |
          .resources[0] = "./../../../rrr/bootnode"' \
            ${TUSKDIR}/k8s/rrr/nodes/node0/kustomization.yaml \
            > rrr/nodes/node${i}/kustomization.yaml
            cat rrr/nodes/node${i}/kustomization.yaml
            echo "Wrote: rrr/nodes/node${i}/kustomization.yaml"
        done

        # kustomizations for the remaining nodes
        # * suffix app and k8s/name labels with the node index
        start=${BBAKE_NUMBOOTNODES}
        end=$(($BBAKE_MAXNODES - 1))
        for i in $(seq $start $end); do
          NODENUM=$i yq eval '.nameSuffix = env(NODENUM) |
          .commonLabels.app += env(NODENUM) |
          .commonLabels."app.kubernetes.io/name" += env(NODENUM)' \
            ${TUSKDIR}/k8s/rrr/nodes/node0/kustomization.yaml \
            > rrr/nodes/node${i}/kustomization.yaml
            cat rrr/nodes/node${i}/kustomization.yaml
            echo "Wrote: rrr/nodes/node${i}/kustomization.yaml"
        done

        # kustomization for the nodes and bootnodes.  XXX: TODO may need to
        # make this conditional as these target files the consumer is expected
        # to change
        export NEWNAME=$(echo $BBAKE_GETH_IMAGE | cut -d ':' -f 1)
        export NEWTAG=$(echo $BBAKE_GETH_IMAGE | cut -d ':' -f 2)
        yq eval --inplace '.images[0].newName = env(NEWNAME)' rrr/bootnode/kustomization.yaml
        yq eval --inplace '.images[0].newTag = env(NEWTAG)' rrr/bootnode/kustomization.yaml
        yq eval --inplace '.images[0].newName = env(NEWNAME)' rrr/node/kustomization.yaml
        yq eval --inplace '.images[0].newTag = env(NEWTAG)' rrr/node/kustomization.yaml

        # volumes for all the nodes. no transformation required
        for i in $(seq 0 $((${BBAKE_MAXNODES} - 1))); do
          cp ${TUSKDIR}/k8s/rrr/nodes/node0/statefulset-volumes.yaml rrr/nodes/node${i}/statefulset-volumes.yaml
          cat rrr/nodes/node${i}/statefulset-volumes.yaml
          echo "Wrote: rrr/nodes/node${i}/statefulset-volumes.yaml"
        done

        for i in $(seq 0 $((${BBAKE_MAXNODES} - 1))); do
        echo "- ./../nodes/node${i}"
        done | \
        yq eval-all 'select(fi==0) *+ {"resources": select(fi==1)}' ${TUSKDIR}/k8s/rrr/network/kustomization.yaml - \
        > rrr/network/kustomization.yaml
        cat rrr/network/kustomization.yaml
        echo "Wrote rrr/network/kustomization.yaml"

        # The namespace is the name - eg rrr7
        yq eval ".namespace = \"$BBAKE_NAME\"" \
          ${TUSKDIR}/k8s/rrr/kustomization.yaml | \
          tee rrr/kustomization.yaml
        echo "Wrote rrr/kustomization.yaml"

        cp ${TUSKDIR}/k8s/rrr/namespace.yaml rrr/
        cat rrr/namespace.yaml
        echo "Wrote rrr/namespace.yaml"

        source ${BBAKE_PYENV}/bin/activate
        cat <<PYEND | python3
        import os, json
        j = None
        with open("bench.json") as f:
            j = json.load(f)
            # The sourcing trick we use doesn't play well with variables that
            # have spaces
            # j["consensus_opts"] = os.environ["CONSENSUS_OPTS"]
            # j["gas_opts"] = os.environ["GAS_OPTS"]
            j["networkid"] = "${BBAKE_NETWORKID}"
            j["numbootnodes"] = "${BBAKE_NUMBOOTNODES}"
            j["gastarget"] = "${BBAKE_GASTARGET}"
            j["gaslimit"] = "${BBAKE_GASLIMIT}"
            j["recommit"] = "${BBAKE_RECOMMIT}"

        if j is not None:
            with open("bench.json", "w") as f:
                json.dump(j, f, indent=2, sort_keys=True)
        PYEND
